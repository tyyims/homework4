---
title: "Homework 4"
subtitle: "Research Methods, Spring 2024"
author: "Taeyoung Yim"
format:
  pdf:
    output-file: "yim-t-hwk4-1"
    output-ext:  "pdf"
    header-includes:
      - \usepackage{float}
      - \floatplacement{table}{H}
---

```{r}
#| include: false

if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, ggplot2, dplyr, lubridate, readr, readxl, hrbrthemes, fixest,
               scales, gganimate, gapminder, gifski, png, tufte, plotly, OECD,
               ggrepel, survey, foreign, devtools, pdftools, kableExtra, modelsummary,
               kableExtra, stringr, data.table, gdata)
```

```{r}
#| include: false
#| eval: true

final.data <- read_rds("data/output/final_ma_data.rds")
```

\newpage
# Summarize the Data
\vspace{.2in}
\noindent 1. Remove all SNPs, 800-series plans, and prescription drug only plans (i.e., plans that do not offer Part C benefits). Provide a box and whisker plot showing the distribution of plan counts by county over time. Do you think that the number of plans is sufficient, too few, or too many?<br>
```{r,  echo = FALSE}
# Filter out SNPs, 800-series plans, and prescription drug only plans
filtered_data <- final.data[!(final.data$snp == 1 | grepl("^800", final.data$planid) | final.data$partc == 0), ]

# Convert contract_date to date format
filtered_data$contract_date <- as.Date(filtered_data$contract_date)

# Count the number of plans by county and year
plan_counts <- aggregate(plan_count ~ county + year, data = filtered_data, FUN = length)

# Filter plan counts data to include only years from 2010 to 2015
plan_counts <- plan_counts[plan_counts$year >= 2010 & plan_counts$year <= 2015, ]

# Box and whisker plot showing distribution of plan counts by county over time without outliers
boxplot(plan_counts$plan_count ~ plan_counts$year, main = "Distribution of Plan Counts by County Over Time (2010-2015)",
        xlab = "Year", ylab = "Plan Counts", col = "lightblue", border = "blue", notch = TRUE, outline = FALSE)
```

\newpage
\vspace{.2in}
\noindent 2. Provide bar graphs showing the distribution of star ratings in 2010, 2012, and 2015. How has this distribution changed over time?<br>
```{r, echo = FASLE}
# Define shades of blue for each year
custom_colors <- c("skyblue", "pink", "darkgreen")

# Filter the data for the years 2010, 2012, and 2015
filtered_data <- final.data[final.data$year %in% c(2010, 2012, 2015), ]

# Create bar graphs for each year
par(mfrow = c(1, 3)) # Set up a 1x3 layout for the plots
for (i in 1:3) {
  # Subset data for the current year
  year_data <- filtered_data[filtered_data$year == c(2010, 2012, 2015)[i], ]
  # Count the frequency of each star rating
  star_counts <- table(year_data$Star_Rating)
  # Create a bar plot with shades of blue for each year
  barplot(star_counts, main = paste("Star Ratings Distribution -", c(2010, 2012, 2015)[i]),
          xlab = "Star Rating", ylab = "Frequency", col = custom_colors[i])
}

```

The distribution decreases over time.

\newpage
\vspace{.2in}
\noindent 3.Plot the average benchmark payment over time from 2010 through 2015. How much has the average benchmark payment risen over the years?.<br>
```{r,  echo = FALSE}
# Filter the data for the years 2010 through 2015
filtered_data <- final.data[final.data$year %in% 2010:2015, ]

# Calculate the average benchmark payment for each year
average_payment <- aggregate(payment_partc ~ year, data = filtered_data, FUN = mean)

# Plot the average benchmark payment over time
plot(average_payment$year, average_payment$payment_partc, type = "o",
     main = "Average Benchmark Payment Over Time (2010-2015)",
     xlab = "Year", ylab = "Average Benchmark Payment")

# Add grid lines for better readability
grid()

# Calculate the rise in average benchmark payment over the years
rise <- diff(average_payment$payment_partc)
rise_over_years <- sum(rise)

# Print the rise in average benchmark payment over the years
cat("The average benchmark payment has risen by", round(rise_over_years, 2), "over the years (2010-2015).")


```


\newpage
\vspace{.2in}
\noindent 4.Plot the average share of Medicare Advantage (relative to all Medicare eligibles) over time from 2010 through 2015. Has Medicare Advantage increased or decreased in popularity? How does this share correlate with benchmark payments?<br>
```{r,  echo = FALSE}
# Filter the data for the years 2010 through 2015
filtered_data <- final.data[final.data$year %in% 2010:2015, ]

# Calculate the average share of Medicare Advantage enrollees relative to all Medicare eligibles for each year
average_ma_share <- filtered_data %>% group_by(fips, year)%>%
  summarize(enroll = first(avg_enrolled), medicare = first(avg_eligibles), bench = mean(ma_rate, na.rm=TRUE))%>%
  mutate(mkt_share = enroll/medicare)

ma.share <- average_ma_share%>%
  ggplot(aes(x = as.factor(year), y = mkt_share, group = 1))+
  stat_summary(fun = "mean", geom= "line", na.rm=TRUE) +
  labs(
    x = "Year",
    y = "MA Market Share"
  ) + theme_bw()
ma.share
```

Medical advantage increased overtime. Comparing this trend with the benchmark payment trend, the over all trend seems to be positively correlated, although the trend is slight different between 2011 and 2013.

\newpage
# Estimate ATEs
For the rest of the assignment, we’ll use a regression discontinuity design to estimate the average treatment effect from receiving a marginally higher rating. We’ll focus only on 2010.
\vspace{.2in}
\noindent 5.Calculate the running variable underlying the star rating. Provide a table showing the number of plans that are rounded up into a 3-star, 3.5-star, 4-star, 4.5-star, and 5-star rating.<br>
```{r, echo = FALSE}
# Load the necessary libraries
library(dplyr)

# Filter the data for the year 2010
data_2010 <- final.data[final.data$year == 2010, ]

# Calculate the running variable as the fractional part of the star rating
data_2010$running_variable <- data_2010$Star_Rating - floor(data_2010$Star_Rating)

# Define the thresholds for rounding up to different star ratings
thresholds <- c(3, 3.5, 4, 4.5, 5)

# Round up the running variable to the nearest threshold for each plan
data_2010$rounded_rating <- cut(data_2010$running_variable, breaks = thresholds, labels = thresholds[-1])

# Create a table showing the number of plans rounded up into specific star ratings
rating_table <- table(data_2010$rounded_rating)

# Display the table
rating_table


```

\newpage

\vspace{.2in}
\noindent 6.Using the RD estimator with a bandwidth of 0.125, provide an estimate of the effect of receiving a 3-star versus a 2.5 star rating on enrollments. Repeat the exercise to estimate the effects at 3.5 stars, and summarize your results in a table.<br>

```{r, echo=FALSE}
# Load the necessary libraries
library(rdrobust)
library(dplyr)

# Filter the data for the year 2010
data_2010 <- final.data[final.data$year == 2010, ]

# Calculate the running variable as the fractional part of the star rating
data_2010$running_variable <- data_2010$Star_Rating - floor(data_2010$Star_Rating)

# Define the bandwidth
bandwidth <- 0.125

# Function to estimate treatment effect for a specific star rating
estimate_treatment_effect <- function(star_rating) {
  # Create a binary treatment variable indicating whether the star rating is above or below the threshold
  data_2010$treatment <- ifelse(data_2010$Star_Rating >= star_rating, 1, 0)
  
  # Run regression discontinuity analysis
  rd_result <- rdrobust(avg_enrolled ~ running_variable + treatment, h = bandwidth)
  
  # Extract and return the treatment effect estimate
  return(coef(rd_result)[3])
}

# Estimating treatment effects for 3-star and 3.5-star ratings
effect_3_star <- estimate_treatment_effect(3)
effect_3.5_star <- estimate_treatment_effect(3.5)

# Summarize results in a table
results_table <- data.frame(
  "Star Rating" = c("3-star", "3.5-star"),
  "Effect on Enrollments" = c(effect_3_star, effect_3.5_star)
)

# Display the table
print(results_table)

```


\newpage
\vspace{.2in}
\noindent 7.Repeat your results for bandwidhts of 0.1, 0.12, 0.13, 0.14, and 0.15 (again for 3 and 3.5 stars). Show all of the results in a graph. How sensitive are your findings to the choice of bandwidth?<br>

```{r, echo=FALSE}
# Load necessary libraries
library(rdrobust)
library(dplyr)
library(ggplot2)

# Function to estimate treatment effect for a specific star rating and bandwidth
estimate_treatment_effect <- function(star_rating, bandwidth) {
  # Filter the data for the year 2010
  data_2010 <- final.data[final.data$year == 2010, ]
  
  # Calculate the running variable as the fractional part of the star rating
  data_2010$running_variable <- data_2010$Star_Rating - floor(data_2010$Star_Rating)
  
  # Create a binary treatment variable indicating whether the star rating is above or below the threshold
  data_2010$treatment <- ifelse(data_2010$Star_Rating >= star_rating, 1, 0)
  
  # Run regression discontinuity analysis
  rd_result <- rdrobust(avg_enrolled ~ running_variable + treatment, data = data_2010, h = bandwidth)
  
  # Extract and return the treatment effect estimate
  return(coef(rd_result)[3])
}

# Define bandwidth values
bandwidths <- c(0.1, 0.12, 0.13, 0.14, 0.15)

# Initialize empty lists to store results
effect_3_star_list <- list()
effect_3.5_star_list <- list()

# Loop through each bandwidth value
for (bw in bandwidths) {
  # Estimate treatment effects for 3-star and 3.5-star ratings
  effect_3_star_list[[as.character(bw)]] <- estimate_treatment_effect(3, bw)
  effect_3.5_star_list[[as.character(bw)]] <- estimate_treatment_effect(3.5, bw)
}

# Create a data frame to store results
results_df <- data.frame(
  Bandwidth = rep(bandwidths, each = 2),
  Star_Rating = rep(c("3-star", "3.5-star"), times = length(bandwidths)),
  Effect_on_Enrollments = c(unlist(effect_3_star_list), unlist(effect_3.5_star_list))
)

# Plot the results
ggplot(results_df, aes(x = Bandwidth, y = Effect_on_Enrollments, color = Star_Rating)) +
  geom_line() +
  geom_point() +
  labs(title = "Effect of Different Bandwidths on Enrollments",
       x = "Bandwidth",
       y = "Effect on Enrollments") +
  theme_minimal() +
  theme(legend.position = "top")


```
I am getting "null" for all, so it is not possible to tell. 

\newpage
\vspace{.2in}
\noindent 8.Examine (graphically) whether contracts appear to manipulate the running variable. In other words, look at the distribution of the running variable before and after the relevent threshold values. What do you find?.<br>
```{r,  echo = FALSE}
#manipulation of running variable
# Define the relevant threshold value
threshold <- 3  # For example, if the threshold for star ratings is 3

# Create subsets of data for scores below and above the threshold
below_threshold <- final.data[!is.na(final.data$mean_risk) & final.data$mean_risk < threshold, ]
above_threshold <- final.data[!is.na(final.data$mean_risk) & final.data$mean_risk >= threshold, ]

# Plot the distribution of scores before and after the threshold using density plots
par(mfrow = c(1, 2))  # Set plotting layout to 1 row and 2 columns

# Density plot for scores below the threshold
plot(density(below_threshold$mean_risk), main = "Density Plot: Scores Below Threshold", xlab = "Mean Risk")

# Check if there are enough data points for the density plot
if (nrow(above_threshold) >= 2) {
  # Density plot for scores above the threshold
  plot(density(above_threshold$mean_risk), main = "Density Plot: Scores Above Threshold", xlab = "Mean Risk")
} else {
  # Print a message indicating insufficient data
  print("Error when drawing above threshold.")
}

```
At my current stage, I cannot compare below threshold and above threshold.
\newpage
\vspace{.2in}
\noindent 9.Similar to question 8, examine whether plans just above the threshold values have different characteristics than contracts just below the threshold values. Use HMO and Part D status as your plan characteristics.<br>
```{r,  echo = FALSE}
#covariant balance

library(dplyr)

# Filter the data for the year 2010
data_2010 <- final.data %>%
  filter(year == 2010)

# Calculate the running variable (star rating rounded up)
data_2010 <- data_2010 %>%
  mutate(running_variable = ceiling(mean_risk))

# Define a function to compare plan characteristics
compare_plan_characteristics <- function(data, threshold) {
  above_threshold <- data %>%
    filter(running_variable > threshold)
  
  below_threshold <- data %>%
    filter(running_variable < threshold)
  
  # Calculate the proportion of HMO and Part D plans for each group
  above_threshold_hmo_prop <- mean(above_threshold$org_type == "HMO")
  above_threshold_partd_prop <- mean(above_threshold$partd == "Yes")
  
  below_threshold_hmo_prop <- mean(below_threshold$org_type == "HMO")
  below_threshold_partd_prop <- mean(below_threshold$partd == "Yes")
  
  # Create a data frame to store the results
  comparison_results <- data.frame(
    Threshold = threshold,
    Plan_Type = c("HMO", "Part D"),
    Above_Threshold_Proportion = c(above_threshold_hmo_prop, above_threshold_partd_prop),
    Below_Threshold_Proportion = c(below_threshold_hmo_prop, below_threshold_partd_prop)
  )
  
  return(comparison_results)
}

# Set threshold values (e.g., 3-star and 3.5-star)
thresholds <- c(3, 3.5)

# Compare plan characteristics for each threshold value
comparison_results <- purrr::map_dfr(thresholds, ~compare_plan_characteristics(data_2010, .x))

# Print comparison results
print(comparison_results)

```

\newpage
\vspace{.2in}
\noindent 10.Summarize your findings from 5-9. What is the effect of increasing a star rating on enrollments? Briefly explain your results.<br>
At my current stage, it is difficult to tell the effect of increasing a star rating since I faced error while executing some codes. Some data seem to be empty, so I need to figure that our first before actually answering this question. 